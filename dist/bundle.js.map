{"version":3,"file":"bundle.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEiC","sources":["webpack://knights-travails/webpack/bootstrap","webpack://knights-travails/webpack/runtime/define property getters","webpack://knights-travails/webpack/runtime/hasOwnProperty shorthand","webpack://knights-travails/webpack/runtime/make namespace object","webpack://knights-travails/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * The goal of this program is to determine the shortest path for a knight to travel from one spot to another on a chess board:\n\nGiven a knight node:\n  1. Compare that node's coordinates to the destination coordinates\n  2. If the coordinates match, a path has been found, and the program logs the coordinates which have been visited\n  3. If the coordinates don't match, determine the next possible moves\n  4. Use each possible move to generate a new node, and assign each node as a child of the given knight node\n  5. Push each new node to the queue\n  6. Dequeue a node, repeat steps 1-5\n */\n\n// Treat knight as a node which stores its current location and possible moves\n\nconst knight = function knightNode(coord = null) {\n  const knight = {};\n\n  knight.coord = coord;\n\n  knight.map = [];\n\n  // Maximum eight possible moves for any given coordinate, can be assigned on the spot\n\n  return knight;\n};\n\n// Given a coordinate, generate a list of the immediate possible moves (up to 8)\n\nconst possibleMoves = function generateImmediatePossibilities(coord) {\n  const x = coord[0];\n  const y = coord[1];\n\n  let possibleMoves = [\n    [x - 2, y + 1],\n    [x - 1, y + 2],\n    [x + 1, y + 2],\n    [x + 2, y + 1],\n    [x + 2, y - 1],\n    [x + 1, y - 2],\n    [x - 1, y - 2],\n    [x - 2, y - 1],\n  ];\n\n  let acceptedMoves = [];\n\n  for (let i = 0; i < 8; i++) {\n    let current = possibleMoves[i];\n    let x = current[0];\n    let y = current[1];\n\n    if (x >= 0 && x <= 7 && y >= 0 && y <= 7) {\n      acceptedMoves.push(current);\n    }\n  }\n\n  return acceptedMoves;\n};\n\nconst knightMoves = function findPath(knightNode, destination) {\n  let coord = knightNode.coord;\n\n  const validCoord = valid(coord);\n  const validDest = valid(destination);\n\n  if (!validCoord || !validDest) {\n    return `Invalid input`;\n  }\n\n  knightNode.map.push(coord);\n  let queue = [];\n  let found = false;\n\n  if (coord[0] === destination[0] && coord[1] === destination[1]) {\n    found = true;\n    return;\n  } else {\n    generateNextSpots(knightNode, coord, queue);\n\n    while (found === false) {\n      let currentNode = queue.shift();\n      coord = currentNode.coord;\n      currentNode.map.push(coord);\n\n      if (coord[0] === destination[0] && coord[1] === destination[1]) {\n        found = true;\n        console.log(currentNode.map);\n      } else {\n        generateNextSpots(currentNode, coord, queue);\n      }\n    }\n  }\n};\n\nconst generateNextSpots = function findNewMovesAndMakeNodes(\n  currentNode,\n  coord,\n  queue\n) {\n  let possibleNextMoves = possibleMoves(coord);\n\n  for (let move in possibleNextMoves) {\n    let newKnight = knight(possibleNextMoves[move]);\n    let prevMap = currentNode.map;\n    for (coord of prevMap) {\n      newKnight.map.push(coord);\n    }\n    currentNode[`node${move}`] = newKnight;\n    queue.push(newKnight);\n  }\n};\n\nconst valid = function checkValidity(coord) {\n  for (let i of coord) {\n    if (i < 0 || i > 7) {\n      console.log(\"Invalid input\");\n      return false;\n    }\n  }\n  return true;\n};\n\nconst newKnight = knight([7, 7]);\n\nknightMoves(newKnight, [7, 6]);\n\nexport { possibleMoves, knight };\n"],"names":[],"sourceRoot":""}